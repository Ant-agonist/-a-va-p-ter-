<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Puissance 4 - Contre l'ordinateur & Score BO3</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #0a3d62;
    color: #f5f6fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 25px;
    margin: 0;
    min-height: 100vh;
  }
  h1 {
    margin-bottom: 5px;
    text-align: center;
  }
  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(7, 70px);
    grid-template-rows: repeat(6, 70px);
    gap: 8px;
    background: #1e3799;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 0 20px #1e3799;
    user-select: none;
  }
  .cell {
    width: 70px;
    height: 70px;
    background-color: #4a69bd;
    border-radius: 50%;
    box-shadow: inset 0 4px 6px #2c3e50;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.25s ease;
    position: relative;
  }
  .cell:hover:not(.full):not(.highlighted) {
    background-color: #60a3bc;
  }
  .cell.full {
    cursor: default;
  }
  .disc {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
    transform: translateY(-150px);
    animation-fill-mode: forwards;
  }
  .player1 {
    background: radial-gradient(circle at 30% 30%, #e74c3c, #b71c1c);
  }
  .player2 {
    background: radial-gradient(circle at 30% 30%, #f1c40f, #b7950b);
  }
  .dropAnimation {
    animation-name: drop;
    animation-duration: 0.5s;
    animation-timing-function: ease-out;
  }
  @keyframes drop {
    0% { transform: translateY(-150px); }
    100% { transform: translateY(0); }
  }

  /* Animation de surbrillance victoire */
  .highlighted {
    animation: blink 1s infinite alternate;
    box-shadow: 0 0 15px 5px yellow;
  }
  @keyframes blink {
    from {
      box-shadow: 0 0 15px 5px yellow;
    }
    to {
      box-shadow: 0 0 30px 10px orange;
    }
  }

  #status {
    margin: 20px 0 10px 0;
    font-size: 1.4em;
    min-height: 40px;
    text-align: center;
  }
  #scoreboard {
    margin-bottom: 20px;
    font-size: 1.2em;
    text-align: center;
  }
  #restart, #resetScore {
    padding: 10px 18px;
    font-size: 1em;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    background-color: #1e3799;
    color: #f5f6fa;
    box-shadow: 0 4px 8px #1e3799;
    transition: background-color 0.3s;
  }
  #restart:hover, #resetScore:hover {
    background-color: #3742fa;
  }
  #footer {
    margin-top: auto;
    font-size: 0.85em;
    color: #ced6e0;
  }

  /* Responsive */
  @media (max-width: 600px) {
    #game {
      grid-template-columns: repeat(7, 40px);
      grid-template-rows: repeat(6, 40px);
      gap: 5px;
      padding: 6px;
    }
    .cell {
      width: 40px;
      height: 40px;
      box-shadow: inset 0 3px 4px #2c3e50;
    }
    .disc {
      width: 35px;
      height: 35px;
    }
    #restart, #resetScore {
      padding: 8px 14px;
      font-size: 0.9em;
    }
    #status {
      font-size: 1.1em;
      margin: 15px 0 8px;
    }
    #scoreboard {
      font-size: 1em;
    }
  }
</style>
</head>
<body>

<h1>Puissance 4 - Contre l'ordinateur & Score BO3</h1>

<div id="controls">
  <button id="restart">Nouvelle partie</button>
  <button id="resetScore">R√©initialiser score</button>
</div>

<div id="scoreboard">
  <span>Score - Joueur (rouge) : <span id="scoreP1">0</span></span> | 
  <span>Ordinateur (jaune) : <span id="scoreP2">0</span></span>
</div>

<div id="status" role="status" aria-live="polite">Joueur (rouge), √† vous de jouer !</div>

<div id="game" aria-label="Grille du jeu Puissance 4" role="grid" tabindex="0"></div>

<div id="footer">Fait avec ‚ù§Ô∏è par ChatGPT</div>

<script>
  const ROWS = 6;
  const COLS = 7;

  let board = [];
  let currentPlayer = 1; // 1 = joueur, 2 = IA
  let gameOver = false;
  let scoreP1 = 0;
  let scoreP2 = 0;

  const gameDiv = document.getElementById('game');
  const statusDiv = document.getElementById('status');
  const restartBtn = document.getElementById('restart');
  const resetScoreBtn = document.getElementById('resetScore');
  const scoreP1Span = document.getElementById('scoreP1');
  const scoreP2Span = document.getElementById('scoreP2');

  let winningCells = [];

  function initBoard() {
    board = [];
    gameDiv.innerHTML = '';
    winningCells = [];
    for(let r = 0; r < ROWS; r++) {
      let row = [];
      for(let c = 0; c < COLS; c++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.setAttribute('role', 'gridcell');
        cell.setAttribute('aria-label', `Ligne ${r+1}, colonne ${c+1}`);
        cell.addEventListener('click', () => {
          if (!gameOver && currentPlayer === 1 && isColumnPlayable(c)) {
            placeDisc(c);
          }
        });
        gameDiv.appendChild(cell);
        row.push(0);
      }
      board.push(row);
    }
    currentPlayer = 1;
    gameOver = false;
    updateStatus(`Joueur (rouge), √† vous de jouer !`);
    updateCellsCursor();
  }

  function updateStatus(message) {
    statusDiv.textContent = message;
  }

  function placeDisc(col) {
    if (gameOver) return;

    for(let row = ROWS -1; row >= 0; row--) {
      if (board[row][col] === 0) {
        board[row][col] = currentPlayer;
        animateDisc(row, col, currentPlayer);

        if (checkWin(row, col)) {
          gameOver = true;
          if (currentPlayer === 1) scoreP1++;
          else scoreP2++;
          updateScore();
          updateStatus(`üéâ ${currentPlayer === 1 ? 'Vous avez' : "L'ordinateur a"} gagn√© !`);
          highlightWinningCells();
        } else if (isDraw()) {
          gameOver = true;
          updateStatus(`Match nul !`);
        } else {
          currentPlayer = currentPlayer === 1 ? 2 : 1;
          updateStatus(`${currentPlayer === 1 ? 'Joueur (rouge), √† vous de jouer !' : "Ordinateur r√©fl√©chit..."}`);
          updateCellsCursor();
          if (currentPlayer === 2 && !gameOver) {
            setTimeout(aiPlay, 700);
          }
        }
        updateCellsCursor();
        return;
      }
    }
  }

  function animateDisc(row, col, player) {
    const cell = gameDiv.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
    if (!cell) return;
    const disc = document.createElement('div');
    disc.classList.add('disc', `player${player}`, 'dropAnimation');
    cell.appendChild(disc);
  }

  function updateScore() {
    scoreP1Span.textContent = scoreP1;
    scoreP2Span.textContent = scoreP2;
    if (scoreP1 >= 2) {
      updateStatus('üèÜ Vous avez gagn√© le BO3 ! üéâ');
      gameOver = true;
      highlightWinningCells();
    } else if (scoreP2 >= 2) {
      updateStatus("üèÜ L'ordinateur a gagn√© le BO3 ! üòû");
      gameOver = true;
      highlightWinningCells();
    }
  }

  function checkWin(row, col) {
    const player = board[row][col];
    if (player === 0) return false;

    function countDir(rStep, cStep) {
      let r = row + rStep;
      let c = col + cStep;
      let count = 0;
      let cells = [];
      while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {
        count++;
        cells.push([r,c]);
        r += rStep;
        c += cStep;
      }
      return {count, cells};
    }

    const directions = [
      [0, 1],   // horizontale droite
      [1, 0],   // verticale bas
      [1, 1],   // diagonale bas droite
      [1, -1]   // diagonale bas gauche
    ];

    for (const [rStep, cStep] of directions) {
      let total = 1;
      let winningCellsList = [[row,col]];

      let res1 = countDir(rStep, cStep);
      let res2 = countDir(-rStep, -cStep);

      total += res1.count + res2.count;
      winningCellsList = winningCellsList.concat(res1.cells, res2.cells);

      if (total >= 4) {
        winningCells = winningCellsList;
        return true;
      }
    }
    return false;
  }

  function isDraw() {
    return board[0].every(cell => cell !== 0);
  }

  function highlightWinningCells() {
    winningCells.forEach(([r,c]) => {
      const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if(cell) cell.classList.add('highlighted');
    });
  }

  function aiPlay() {
    if (gameOver) return;

    // Colonnes non pleines
    let availableCols = [];
    for(let c = 0; c < COLS; c++) {
      if (board[0][c] === 0) availableCols.push(c);
    }
    if (availableCols.length === 0) return;

    // Essayer de gagner
    for (const c of availableCols) {
      let r = getNextEmptyRow(c);
      if (r === -1) continue;
      board[r][c] = 2;
      if (checkWin(r, c)) {
        board[r][c] = 0;
        placeDisc(c);
        return;
      }
      board[r][c] = 0;
    }

    // Essayer de bloquer joueur
    for (const c of availableCols) {
      let r = getNextEmptyRow(c);
      if (r === -1) continue;
      board[r][c] = 1;
      if (checkWin(r, c)) {
        board[r][c] = 0;
        placeDisc(c);
        return;
      }
      board[r][c] = 0;
    }

    // Sinon colonne al√©atoire
    const choice = availableCols[Math.floor(Math.random() * availableCols.length)];
    placeDisc(choice);
  }

  function getNextEmptyRow(col) {
    for(let r = ROWS - 1; r >= 0; r--) {
      if (board[r][col] === 0) return r;
    }
    return -1;
  }

  function isColumnPlayable(col) {
    return board[0][col] === 0;
  }

  function updateCellsCursor() {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
        if (!cell) continue;

        if(gameOver) {
          cell.style.cursor = 'default';
          continue;
        }

        if(r === getNextEmptyRow(c)) {
          cell.style.cursor = currentPlayer === 1 ? 'pointer' : 'default';
          cell.classList.remove('full');
        } else {
          cell.style.cursor = 'default';
          cell.classList.add('full');
        }
      }
    }
  }

  restartBtn.addEventListener('click', () => {
    if (gameOver) {
      initBoard();
    } else {
      if(confirm("Voulez-vous abandonner la partie en cours ?")) {
        initBoard();
      }
    }
  });

  resetScoreBtn.addEventListener('click', () => {
    scoreP1 = 0;
    scoreP2 = 0;
    updateScore();
    initBoard();
  });

  // Init
  initBoard();
  updateScore();

</script>

</body>
</html>
