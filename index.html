<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Puissance 4 avec Bombe & IA avanc√©e</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #0a3d62;
    color: #f5f6fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 25px;
    margin: 0;
    min-height: 100vh;
  }
  h1 {
    margin-bottom: 5px;
    text-align: center;
  }
  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
  }
  #difficultySelect {
    padding: 6px 10px;
    font-size: 1em;
    border-radius: 5px;
    border: none;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(7, 70px);
    grid-template-rows: repeat(6, 70px);
    gap: 8px;
    background: #1e3799;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 0 20px #1e3799;
    user-select: none;
  }
  .cell {
    width: 70px;
    height: 70px;
    background-color: #4a69bd;
    border-radius: 50%;
    box-shadow: inset 0 4px 6px #2c3e50;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.25s ease;
    position: relative;
  }
  .cell:hover:not(.full):not(.highlighted) {
    background-color: #60a3bc;
  }
  .cell.full {
    cursor: default;
  }
  .disc {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
    transform: translateY(-150px);
    animation-fill-mode: forwards;
  }
  .player1 {
    background: radial-gradient(circle at 30% 30%, #e74c3c, #b71c1c);
  }
  .player2 {
    background: radial-gradient(circle at 30% 30%, #f1c40f, #b7950b);
  }
  .bomb {
    font-size: 30px;
    color: black;
    text-shadow: 1px 1px 3px #fff inset;
  }
  .dropAnimation {
    animation-name: drop;
    animation-duration: 0.5s;
    animation-timing-function: ease-out;
  }
  @keyframes drop {
    0% { transform: translateY(-150px); }
    100% { transform: translateY(0); }
  }
  .highlighted {
    animation: blink 1s infinite alternate;
    box-shadow: 0 0 15px 5px yellow;
  }
  @keyframes blink {
    from {
      box-shadow: 0 0 15px 5px yellow;
    }
    to {
      box-shadow: 0 0 30px 10px orange;
    }
  }
  #status {
    margin: 20px 0 10px 0;
    font-size: 1.4em;
    min-height: 40px;
    text-align: center;
  }
  #scoreboard {
    margin-bottom: 20px;
    font-size: 1.2em;
    text-align: center;
  }
  #restart, #resetScore {
    padding: 10px 18px;
    font-size: 1em;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    background-color: #1e3799;
    color: #f5f6fa;
    box-shadow: 0 4px 8px #1e3799;
    transition: background-color 0.3s;
  }
  #restart:hover, #resetScore:hover {
    background-color: #3742fa;
  }
  #footer {
    margin-top: auto;
    font-size: 0.85em;
    color: #ced6e0;
  }
  /* Responsive */
  @media (max-width: 600px) {
    #game {
      grid-template-columns: repeat(7, 40px);
      grid-template-rows: repeat(6, 40px);
      gap: 5px;
      padding: 6px;
    }
    .cell {
      width: 40px;
      height: 40px;
      box-shadow: inset 0 3px 4px #2c3e50;
    }
    .disc {
      width: 35px;
      height: 35px;
    }
    #restart, #resetScore {
      padding: 8px 14px;
      font-size: 0.9em;
    }
    #status {
      font-size: 1.1em;
      margin: 15px 0 8px;
    }
    #scoreboard {
      font-size: 1em;
    }
  }
</style>
</head>
<body>

<h1>Puissance 4 avec Bombe & IA avanc√©e</h1>

<div id="controls">
  <label for="difficultySelect">Difficult√© IA :</label>
  <select id="difficultySelect" aria-label="Choisir la difficult√© de l'ordinateur">
    <option value="medium" selected>Moyen</option>
    <option value="hard">Difficile</option>
  </select>
  <button id="restart">Nouvelle partie</button>
  <button id="resetScore">R√©initialiser score</button>
</div>

<div id="scoreboard" aria-live="polite" aria-atomic="true">
  <span>Score - Joueur (rouge) : <span id="scoreP1">0</span></span> | 
  <span>Ordinateur (jaune) : <span id="scoreP2">0</span></span>
</div>

<div id="status" role="status" aria-live="polite">Joueur (rouge), √† vous de jouer !</div>

<div id="game" aria-label="Grille du jeu Puissance 4" role="grid" tabindex="0"></div>

<div id="footer">Fait avec ‚ù§Ô∏è par ChatGPT</div>

<script>
  const ROWS = 6;
  const COLS = 7;
  const MAX_DEPTH = 4;

  let board = [];
  let currentPlayer = 1; // 1 = joueur, 2 = IA
  let gameOver = false;
  let scoreP1 = 0;
  let scoreP2 = 0;
  let winningCells = [];
  let difficulty = 'medium'; // 'medium' or 'hard'

  const gameDiv = document.getElementById('game');
  const statusDiv = document.getElementById('status');
  const restartBtn = document.getElementById('restart');
  const resetScoreBtn = document.getElementById('resetScore');
  const scoreP1Span = document.getElementById('scoreP1');
  const scoreP2Span = document.getElementById('scoreP2');
  const difficultySelect = document.getElementById('difficultySelect');

  difficultySelect.addEventListener('change', () => {
    difficulty = difficultySelect.value;
  });

  function initBoard() {
    board = [];
    gameDiv.innerHTML = '';
    winningCells = [];
    for(let r = 0; r < ROWS; r++) {
      let row = [];
      for(let c = 0; c < COLS; c++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.setAttribute('role', 'gridcell');
        cell.setAttribute('aria-label', `Ligne ${r+1}, colonne ${c+1}`);
        cell.addEventListener('click', () => {
          if (!gameOver && currentPlayer === 1 && isColumnPlayable(c)) {
            placeDisc(c, 1);
          }
        });
        gameDiv.appendChild(cell);
        row.push(0);
      }
      board.push(row);
    }
    currentPlayer = 1;
    gameOver = false;
    updateStatus(`Joueur (rouge), √† vous de jouer !`);
    updateCellsCursor();
  }

  function updateStatus(message) {
    statusDiv.textContent = message;
  }

  // placeDisc avec param√®tre player et bombage
  // si joueur 1, bombes 10% chance
  function placeDisc(col, player, isFromGravity=false) {
    if (gameOver) return;

    for(let row = ROWS -1; row >= 0; row--) {
      if (board[row][col] === 0) {
        let isBomb = false;
        if (!isFromGravity && player === 1) {
          isBomb = Math.random() < 0.10;
        } else if (!isFromGravity && player === 2) {
          // Option : IA peut aussi avoir bombes ? Ici non.
          isBomb = false;
        }

        board[row][col] = player * (isBomb ? 10 : 1); // bombe = 10*player (10 ou 20)

        animateDisc(row, col, player, isBomb);

        if (!isFromGravity && isBomb) {
          // bombe => enlever jeton adverse al√©atoire
          removeRandomOpponentDisc(player);
          applyGravity();
          renderBoardAfterGravity();
          // check victoire apr√®s gravit√©
          if (checkWinAfterGravity(player)) {
            gameOver = true;
            if (player === 1) scoreP1++;
            else scoreP2++;
            updateScore();
            updateStatus(`üéâ ${player === 1 ? 'Vous avez' : "L'ordinateur a"} gagn√© apr√®s explosion !`);
            highlightWinningCells();
            return;
          }
        }

        if (!isFromGravity) {
          if (checkWin(row, col)) {
            gameOver = true;
            if (player === 1) scoreP1++;
            else scoreP2++;
            updateScore();
            updateStatus(`üéâ ${player === 1 ? 'Vous avez' : "L'ordinateur a"} gagn√© !`);
            highlightWinningCells();
          } else if (isDraw()) {
            gameOver = true;
            updateStatus(`Match nul !`);
          } else {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateStatus(`${currentPlayer === 1 ? 'Joueur (rouge), √† vous de jouer !' : "Ordinateur r√©fl√©chit..."}`);
            updateCellsCursor();
            if (currentPlayer === 2 && !gameOver) {
              setTimeout(aiPlay, 700);
            }
          }
          updateCellsCursor();
        }
        return;
      }
    }
  }

  function animateDisc(row, col, player, isBomb) {
    const cell = gameDiv.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
    if (!cell) return;
    cell.innerHTML = ''; // clear before adding disc
    const disc = document.createElement('div');
    disc.classList.add('disc', `player${player}`, 'dropAnimation');
    if (isBomb) {
      disc.innerHTML = 'üí£';
      disc.classList.add('bomb');
    }
    cell.appendChild(disc);
  }

  function updateScore() {
    scoreP1Span.textContent = scoreP1;
    scoreP2Span.textContent = scoreP2;
    if (scoreP1 >= 2) {
      updateStatus('üèÜ Vous avez gagn√© le BO3 ! üéâ');
      gameOver = true;
      highlightWinningCells();
    } else if (scoreP2 >= 2) {
      updateStatus('üíª L\'ordinateur a gagn√© le BO3 ! üòû');
      gameOver = true;
      highlightWinningCells();
    }
  }

  function isColumnPlayable(col) {
    return board[0][col] === 0;
  }

  function checkWin(row, col) {
    const playerVal = Math.floor(board[row][col] / 10) > 0 ? Math.floor(board[row][col]/10) : board[row][col];
    winningCells = [];

    // directions to check: horizontal, vertical, diag1, diag2
    const directions = [
      { dr: 0, dc: 1 },
      { dr: 1, dc: 0 },
      { dr: 1, dc: 1 },
      { dr: 1, dc: -1 },
    ];

    for (const {dr, dc} of directions) {
      let count = 1;
      let line = [[row,col]];
      // check one side
      for(let i=1; i<4; i++) {
        let nr = row + dr*i;
        let nc = col + dc*i;
        if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
        let val = Math.floor(board[nr][nc]/10) > 0 ? Math.floor(board[nr][nc]/10) : board[nr][nc];
        if (val === playerVal) {
          count++;
          line.push([nr,nc]);
        } else break;
      }
      // check opposite side
      for(let i=1; i<4; i++) {
        let nr = row - dr*i;
        let nc = col - dc*i;
        if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
        let val = Math.floor(board[nr][nc]/10) > 0 ? Math.floor(board[nr][nc]/10) : board[nr][nc];
        if (val === playerVal) {
          count++;
          line.push([nr,nc]);
        } else break;
      }
      if (count >= 4) {
        winningCells = line;
        return true;
      }
    }
    return false;
  }

  // Highlight winning cells with animation
  function highlightWinningCells() {
    if (!winningCells.length) return;
    for(const [r,c] of winningCells) {
      const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if(cell) cell.classList.add('highlighted');
    }
  }

  function isDraw() {
    for(let c=0; c < COLS; c++) {
      if(board[0][c] === 0) return false;
    }
    return true;
  }

  // Remove random opponent disc when bomb explodes
  function removeRandomOpponentDisc(player) {
    const opponent = player === 1 ? 2 : 1;
    let opponentPositions = [];
    for(let r=0; r < ROWS; r++) {
      for(let c=0; c < COLS; c++) {
        let val = Math.floor(board[r][c]/10) > 0 ? Math.floor(board[r][c]/10) : board[r][c];
        if(val === opponent) {
          opponentPositions.push([r,c]);
        }
      }
    }
    if(opponentPositions.length === 0) return; // rien √† enlever

    // choisir un jeton adverse al√©atoire √† retirer
    const [rr,cc] = opponentPositions[Math.floor(Math.random()*opponentPositions.length)];
    board[rr][cc] = 0;
  }

  // Appliquer gravit√© : faire tomber jetons dans colonnes si trou
  function applyGravity() {
    for(let c=0; c<COLS; c++) {
      let newCol = [];
      // collect non-zero jetons (disc or bomb)
      for(let r=ROWS-1; r>=0; r--) {
        if(board[r][c] !== 0) newCol.push(board[r][c]);
      }
      // remplir la colonne en partant du bas
      for(let r=ROWS-1; r>=0; r--) {
        board[r][c] = newCol[ROWS-1 - r] || 0;
      }
    }
  }

  // Met √† jour visuellement la grille apr√®s gravit√© (animation plus simple)
  function renderBoardAfterGravity() {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
        cell.innerHTML = '';
        let val = board[r][c];
        if(val !== 0) {
          let player = Math.floor(val/10) > 0 ? Math.floor(val/10) : val;
          let isBomb = val >= 10;
          const disc = document.createElement('div');
          disc.classList.add('disc', `player${player}`, 'dropAnimation');
          if(isBomb) {
            disc.innerHTML = 'üí£';
            disc.classList.add('bomb');
          }
          cell.appendChild(disc);
        }
      }
    }
  }

  // AI play
  function aiPlay() {
    if(gameOver) return;
    if(difficulty === 'medium') {
      mediumAIPlay();
    } else {
      hardAIPlay();
    }
  }

  // AI moyen : blocage simple + victoire
  function mediumAIPlay() {
    // 1) Peut-il gagner au prochain coup ?
    for(let c=0; c<COLS; c++) {
      if(!isColumnPlayable(c)) continue;
      let row = getNextRow(c);
      board[row][c] = 2; // joue IA
      if(checkWin(row,c)) {
        board[row][c] = 0;
        placeDisc(c, 2);
        return;
      }
      board[row][c] = 0;
    }
    // 2) Bloquer victoire joueur ?
    for(let c=0; c<COLS; c++) {
      if(!isColumnPlayable(c)) continue;
      let row = getNextRow(c);
      board[row][c] = 1; // joue joueur
      if(checkWin(row,c)) {
        board[row][c] = 0;
        placeDisc(c, 2);
        return;
      }
      board[row][c] = 0;
    }
    // 3) Sinon jouer coup al√©atoire jouable
    let validCols = [];
    for(let c=0; c<COLS; c++) {
      if(isColumnPlayable(c)) validCols.push(c);
    }
    if(validCols.length > 0) {
      const c = validCols[Math.floor(Math.random()*validCols.length)];
      placeDisc(c, 2);
    }
  }

  // IA difficile avec mini-max
  function hardAIPlay() {
    let bestScore = -Infinity;
    let bestCol = null;
    for(let c=0; c<COLS; c++) {
      if(!isColumnPlayable(c)) continue;
      let row = getNextRow(c);
      board[row][c] = 2;
      let score = minimax(board, MAX_DEPTH -1, false, -Infinity, Infinity);
      board[row][c] = 0;
      if(score > bestScore) {
        bestScore = score;
        bestCol = c;
      }
    }
    if(bestCol !== null) placeDisc(bestCol, 2);
    else mediumAIPlay();
  }

  // Retourne la ligne o√π tomberait un jeton dans la colonne
  function getNextRow(col) {
    for(let r=ROWS-1; r>=0; r--) {
      if(board[r][col] === 0) return r;
    }
    return -1;
  }

  // Mini-max avec √©lagage alpha-beta
  // playerMax = true => IA joue (player=2)
  function minimax(boardState, depth, playerMax, alpha, beta) {
    if(depth === 0) return evaluateBoard(boardState);
    if(isTerminalNode(boardState)) {
      if(checkBoardWin(boardState, 2)) return 10000;
      else if(checkBoardWin(boardState, 1)) return -10000;
      else return 0;
    }

    if(playerMax) {
      let maxEval = -Infinity;
      for(let c=0; c<COLS; c++) {
        let r = getNextRowForBoard(boardState,c);
        if(r === -1) continue;
        boardState[r][c] = 2;
        let evalScore = minimax(boardState, depth-1, false, alpha, beta);
        boardState[r][c] = 0;
        maxEval = Math.max(maxEval, evalScore);
        alpha = Math.max(alpha, evalScore);
        if(beta <= alpha) break;
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for(let c=0; c<COLS; c++) {
        let r = getNextRowForBoard(boardState,c);
        if(r === -1) continue;
        boardState[r][c] = 1;
        let evalScore = minimax(boardState, depth-1, true, alpha, beta);
        boardState[r][c] = 0;
        minEval = Math.min(minEval, evalScore);
        beta = Math.min(beta, evalScore);
        if(beta <= alpha) break;
      }
      return minEval;
    }
  }

  // Retourne la ligne du prochain jeton sur un board donn√©
  function getNextRowForBoard(boardState, col) {
    for(let r=ROWS-1; r>=0; r--) {
      if(boardState[r][col] === 0) return r;
    }
    return -1;
  }

  // V√©rifie victoire sur board donn√© pour player
  function checkBoardWin(boardState, player) {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(boardState[r][c] !== player) continue;
        // check 4 directions
        if(checkWinDirection(boardState, r, c, player, 0,1)) return true;
        if(checkWinDirection(boardState, r, c, player, 1,0)) return true;
        if(checkWinDirection(boardState, r, c, player, 1,1)) return true;
        if(checkWinDirection(boardState, r, c, player, 1,-1)) return true;
      }
    }
    return false;
  }

  // Check 4 jetons cons√©cutifs dans direction dr,dc
  function checkWinDirection(boardState, r, c, player, dr, dc) {
    let count = 0;
    for(let i=0; i<4; i++) {
      let nr = r + dr*i;
      let nc = c + dc*i;
      if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return false;
      if(boardState[nr][nc] !== player) return false;
      count++;
    }
    return count === 4;
  }

  // √âvaluation simple du plateau pour minimax (diff√©rence jetons)
  function evaluateBoard(boardState) {
    let score = 0;
    // Simple heuristique : +100 pour chaque 4 en ligne IA, -100 pour joueur, +10 pour 3, -10 pour joueur 3, etc
    if(checkBoardWin(boardState, 2)) return 10000;
    if(checkBoardWin(boardState, 1)) return -10000;

    // Bonus 3 en ligne (approximatif)
    score += countSequences(boardState, 2, 3) * 10;
    score -= countSequences(boardState, 1, 3) * 10;

    // Bonus 2 en ligne
    score += countSequences(boardState, 2, 2);
    score -= countSequences(boardState, 1, 2);

    return score;
  }

  // Compte s√©quences cons√©cutives de longueur n pour player
  function countSequences(boardState, player, length) {
    let count = 0;
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(boardState[r][c] !== player) continue;
        if(checkWinDirection(boardState, r, c, player, 0, 1)) {
          if(checkLength(boardState, r, c, player, 0, 1) === length) count++;
        }
        if(checkWinDirection(boardState, r, c, player, 1, 0)) {
          if(checkLength(boardState, r, c, player, 1, 0) === length) count++;
        }
        if(checkWinDirection(boardState, r, c, player, 1, 1)) {
          if(checkLength(boardState, r, c, player, 1, 1) === length) count++;
        }
        if(checkWinDirection(boardState, r, c, player, 1, -1)) {
          if(checkLength(boardState, r, c, player, 1, -1) === length) count++;
        }
      }
    }
    return count;
  }

  // Check longueur exacte n dans direction dr, dc
  function checkLength(boardState, r, c, player, dr, dc) {
    let length = 0;
    for(let i=0; i<4; i++) {
      let nr = r + dr*i;
      let nc = c + dc*i;
      if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
      if(boardState[nr][nc] === player) length++;
      else break;
    }
    return length;
  }

  // Apr√®s explosion gravit√© check victoire pour player
  function checkWinAfterGravity(player) {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        let val = Math.floor(board[r][c]/10) > 0 ? Math.floor(board[r][c]/10) : board[r][c];
        if(val === player) {
          if(checkWin(r,c)) return true;
        }
      }
    }
    return false;
  }

  // Update cursor styles for playable columns
  function updateCellsCursor() {
    for(let c=0; c<COLS; c++) {
      let colPlayable = isColumnPlayable(c);
      for(let r=0; r<ROWS; r++) {
        const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
        if(cell) {
          if(!gameOver && currentPlayer === 1 && colPlayable && board[r][c] === 0 && r === getNextRow(c)) {
            cell.classList.add('highlighted');
          } else {
            cell.classList.remove('highlighted');
          }
        }
      }
    }
  }

  // Boutons restart/reset score
  restartBtn.addEventListener('click', () => {
    if (scoreP1 >= 2 || scoreP2 >= 2) {
      scoreP1 = 0; scoreP2 = 0;
      updateScore();
    }
    initBoard();
  });

  resetScoreBtn.addEventListener('click', () => {
    scoreP1 = 0; scoreP2 = 0;
    updateScore();
  });

  // Initialisation
  initBoard();

</script>

</body>
</html>

