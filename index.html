<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Puissance 4 vs IA avec bombes</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1e2a47;
      color: white;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(7, 60px);
      grid-template-rows: repeat(6, 60px);
      gap: 5px;
      background: #0a1a2a;
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 20px;
      user-select: none;
      width: 100%;
      max-width: 420px;
    }
    .cell {
      background: #003366;
      border-radius: 50%;
      box-shadow: inset 0 0 5px #001a33;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .cell.highlighted {
      box-shadow: 0 0 10px 4px #ffd700 inset;
    }
    .disc {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin: 5px auto;
      transition: transform 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      user-select: none;
    }
    .player1 {
      background: radial-gradient(circle at center, #ff4444, #aa0000);
      box-shadow: 0 0 10px #ff4444;
      color: white;
    }
    .player2 {
      background: radial-gradient(circle at center, #44aaff, #0055aa);
      box-shadow: 0 0 10px #44aaff;
      color: white;
    }
    .bomb {
      font-size: 24px;
      color: yellow;
      text-shadow: 0 0 8px #ffcc00;
    }
    .highlighted {
      animation: pulse 1s infinite alternate;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 10px 4px #ffd700 inset; }
      100% { box-shadow: 0 0 20px 8px #ffec5c inset; }
    }
    #status {
      margin-bottom: 15px;
      font-size: 1.2em;
      min-height: 1.5em;
    }
    #controls {
      margin-bottom: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 8px 16px;
      font-size: 1em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #0055aa;
      color: white;
      transition: background 0.3s ease;
    }
    button:hover:not(:disabled) {
      background: #0077dd;
    }
    button:disabled {
      background: #333;
      cursor: default;
    }
    select {
      font-size: 1em;
      padding: 6px 12px;
      border-radius: 5px;
      border: none;
      background: #003366;
      color: white;
    }
    #scoreboard {
      font-size: 1.1em;
      margin-bottom: 20px;
      text-align: center;
    }
    @media (max-width: 480px) {
      #game {
        grid-template-columns: repeat(7, 40px);
        grid-template-rows: repeat(6, 40px);
        gap: 4px;
        max-width: 300px;
      }
      .disc {
        width: 34px;
        height: 34px;
        margin: 3px auto;
        font-size: 20px;
      }
      .bomb {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>

  <h1>Puissance 4 vs Ordinateur</h1>

  <div id="status">√Ä vous de jouer !</div>

  <div id="controls">
    <label for="difficulty">Difficult√© IA :</label>
    <select id="difficulty">
      <option value="medium">Moyenne</option>
      <option value="hard">Difficile</option>
    </select>
    <button id="restartBtn">Recommencer</button>
    <button id="resetScoreBtn">R√©initialiser Score</button>
  </div>

  <div id="scoreboard">
    Joueur : <span id="scoreP1">0</span> - Ordinateur : <span id="scoreP2">0</span> (BO3)
  </div>

  <div id="game"></div>

  <script>
    const ROWS = 6;
    const COLS = 7;
    const BOMB_CHANCE = 0.1;
    const MAX_DEPTH = 3; // profondeur mini-max r√©duite

    const gameDiv = document.getElementById('game');
    const statusDiv = document.getElementById('status');
    const difficultySelect = document.getElementById('difficulty');
    const restartBtn = document.getElementById('restartBtn');
    const resetScoreBtn = document.getElementById('resetScoreBtn');
    const scoreP1Span = document.getElementById('scoreP1');
    const scoreP2Span = document.getElementById('scoreP2');

    let board = [];
    let gameOver = false;
    let currentPlayer = 1; // 1 = joueur, 2 = IA
    let winningCells = [];
    let scoreP1 = 0;
    let scoreP2 = 0;
    let difficulty = difficultySelect.value;

    difficultySelect.addEventListener('change', () => {
      difficulty = difficultySelect.value;
    });

    function initBoard() {
      board = [];
      for(let r=0; r<ROWS; r++) {
        board.push(new Array(COLS).fill(0));
      }
      gameOver = false;
      currentPlayer = 1;
      winningCells = [];
      statusDiv.textContent = "√Ä vous de jouer !";
      renderBoard();
      updateCellsCursor();
    }

    function renderBoard() {
      gameDiv.innerHTML = '';
      for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.row = r;
          cell.dataset.col = c;
          if(winningCells.some(([wr,wc]) => wr === r && wc === c)) {
            cell.classList.add('highlighted');
          }
          cell.addEventListener('click', () => {
            if(gameOver) return;
            if(currentPlayer !== 1) return;
            if(!isColumnPlayable(c)) return;
            playerPlay(c);
          });
          gameDiv.appendChild(cell);
        }
      }
      renderDiscs();
    }

    function renderDiscs() {
      for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
          const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
          cell.innerHTML = '';
          const val = board[r][c];
          if(val !== 0) {
            const isBomb = val >= 10;
            const player = isBomb ? Math.floor(val/10) : val;
            const disc = document.createElement('div');
            disc.classList.add('disc', `player${player}`, 'dropAnimation');
            if(isBomb) {
              disc.textContent = 'üí£';
              disc.classList.add('bomb');
            }
            cell.appendChild(disc);
          }
        }
      }
    }

    function isColumnPlayable(col) {
      return board[0][col] === 0;
    }

    function getNextRow(col) {
      for(let r=ROWS-1; r>=0; r--) {
        if(board[r][col] === 0) return r;
      }
      return -1;
    }

    function playerPlay(col) {
      if(gameOver) return;
      const row = getNextRow(col);
      if(row === -1) return;

      // Chance de bombes
      const isBomb = Math.random() < BOMB_CHANCE;
      board[row][col] = isBomb ? 10 + 1 : 1; // 10+1 = bombe joueur1, 1 = jeton normal

      renderBoard();

      if(isBomb) {
        removeRandomOpponentDisc(1);
        applyGravity();
        renderBoard();
      }

      if(checkWin(row, col)) {
        scoreP1++;
        updateScore();
        statusDiv.textContent = `üéâ Vous avez gagn√© cette manche !`;
        gameOver = true;
        highlightWinningCells();
        checkBO3();
        return;
      }
      if(isDraw()) {
        statusDiv.textContent = "Match nul !";
        gameOver = true;
        checkBO3();
        return;
      }

      currentPlayer = 2;
      statusDiv.textContent = "L'ordinateur r√©fl√©chit...";
      setTimeout(() => aiPlay(), 300);
    }

    function placeDisc(col, player) {
      const row = getNextRow(col);
      if(row === -1) return false;

      const isBomb = Math.random() < BOMB_CHANCE;
      board[row][col] = isBomb ? 10 + player : player;

      renderBoard();

      if(isBomb) {
        removeRandomOpponentDisc(player);
        applyGravity();
        renderBoard();
      }

      if(checkWin(row, col)) {
        if(player === 2) {
          scoreP2++;
          updateScore();
          statusDiv.textContent = "üíª L'ordinateur a gagn√© cette manche !";
        }
        gameOver = true;
        highlightWinningCells();
        checkBO3();
        return true;
      }
      if(isDraw()) {
        statusDiv.textContent = "Match nul !";
        gameOver = true;
        checkBO3();
        return true;
      }

      currentPlayer = player === 1 ? 2 : 1;
      statusDiv.textContent = currentPlayer === 1 ? "√Ä vous de jouer !" : "L'ordinateur r√©fl√©chit...";
      updateCellsCursor();
      return true;
    }

    function checkWin(row, col) {
      const val = board[row][col];
      const playerVal = Math.floor(val / 10) > 0 ? Math.floor(val / 10) : val;
      winningCells = [];

      const directions = [
        { dr: 0, dc: 1 },
        { dr: 1, dc: 0 },
        { dr: 1, dc: 1 },
        { dr: 1, dc: -1 },
      ];

      for(const {dr, dc} of directions) {
        let count = 1;
        let line = [[row, col]];

        // check one side
        for(let i=1; i<4; i++) {
          const nr = row + dr*i;
          const nc = col + dc*i;
          if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
          let val = board[nr][nc];
          let valPlayer = Math.floor(val / 10) > 0 ? Math.floor(val / 10) : val;
          if(valPlayer === playerVal) {
            count++;
            line.push([nr,nc]);
          } else break;
        }
        // check opposite side
        for(let i=1; i<4; i++) {
          const nr = row - dr*i;
          const nc = col - dc*i;
          if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
          let val = board[nr][nc];
          let valPlayer = Math.floor(val / 10) > 0 ? Math.floor(val / 10) : val;
          if(valPlayer === playerVal) {
            count++;
            line.push([nr,nc]);
          } else break;
        }
        if(count >= 4) {
          winningCells = line;
          return true;
        }
      }
      return false;
    }

    function highlightWinningCells() {
      renderBoard();
      for(const [r,c] of winningCells) {
        const cell = gameDiv.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
        if(cell) {
          cell.classList.add('highlighted');
        }
      }
    }

    function isDraw() {
      for(let c=0; c<COLS; c++) {
        if(board[0][c] === 0) return false;
      }
      return true;
    }

    // Supprime un jeton adverse au hasard (bombes)
    function removeRandomOpponentDisc(player) {
      const opponent = player === 1 ? 2 : 1;
      const opponentPositions = [];
      for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
          let val = board[r][c];
          if(val !== 0) {
            let valPlayer = Math.floor(val / 10) > 0 ? Math.floor(val / 10) : val;
            if(valPlayer === opponent) {
              opponentPositions.push([r,c]);
            }
          }
        }
      }
      if(opponentPositions.length === 0) return; // rien √† supprimer
      const [rr, cc] = opponentPositions[Math.floor(Math.random() * opponentPositions.length)];
      board[rr][cc] = 0;
    }

    // Appliquer la gravit√© apr√®s suppression jeton (bombes)
    function applyGravity() {
      for(let c=0; c<COLS; c++) {
        let stack = [];
        for(let r=ROWS-1; r>=0; r--) {
          if(board[r][c] !== 0) {
            stack.push(board[r][c]);
            board[r][c] = 0;
          }
        }
        let r = ROWS-1;
        for(const val of stack) {
          board[r][c] = val;
          r--;
        }
      }
    }

    function updateScore() {
      scoreP1Span.textContent = scoreP1;
      scoreP2Span.textContent = scoreP2;
    }

    function checkBO3() {
      if(scoreP1 >= 2) {
        statusDiv.textContent = "üéâ F√©licitations, vous avez gagn√© le BO3 !";
        gameOver = true;
      } else if(scoreP2 >= 2) {
        statusDiv.textContent = "L'ordinateur a gagn√© le BO3. Essayez encore !";
        gameOver = true;
      } else if(gameOver) {
        setTimeout(() => {
          initBoard();
        }, 2000);
      }
    }

    restartBtn.addEventListener('click', () => {
      initBoard();
    });
    resetScoreBtn.addEventListener('click', () => {
      scoreP1 = 0;
      scoreP2 = 0;
      updateScore();
      initBoard();
      statusDiv.textContent = "Score r√©initialis√©. √Ä vous de jouer !";
    });

    function updateCellsCursor() {
      const allCells = gameDiv.querySelectorAll('.cell');
      allCells.forEach(cell => {
        const col = +cell.dataset.col;
        if(isColumnPlayable(col) && currentPlayer === 1 && !gameOver) {
          cell.style.cursor = 'pointer';
        } else {
          cell.style.cursor = 'default';
        }
      });
    }

    // ---------------- AI ----------------

    function aiPlay() {
      if(gameOver) return;
      let col;
      if(difficulty === 'medium') {
        col = randomMove();
      } else {
        col = bestMove(board, MAX_DEPTH);
      }
      placeDisc(col, 2);
      if(!gameOver) {
        currentPlayer = 1;
        statusDiv.textContent = "√Ä vous de jouer !";
        updateCellsCursor();
      }
    }

    function randomMove() {
      const validCols = [];
      for(let c=0; c<COLS; c++) {
        if(isColumnPlayable(c)) validCols.push(c);
      }
      return validCols[Math.floor(Math.random() * validCols.length)];
    }

    // Mini-max avec √©lagage alpha-beta, profondeur limit√©e
    function bestMove(boardState, depth) {
      let bestScore = -Infinity;
      let bestCol = null;
      for(let c=0; c<COLS; c++) {
        const r = getNextRowForBoard(boardState, c);
        if(r === -1) continue;
        boardState[r][c] = 2;
        let score = minimax(boardState, depth - 1, false, -Infinity, Infinity);
        boardState[r][c] = 0;
        if(score > bestScore) {
          bestScore = score;
          bestCol = c;
        }
      }
      if(bestCol === null) return randomMove();
      return bestCol;
    }

    function minimax(boardState, depth, maximizingPlayer, alpha, beta) {
      if(depth === 0 || isTerminalNode(boardState)) {
        return evaluateBoard(boardState);
      }
      if(maximizingPlayer) {
        let maxEval = -Infinity;
        for(let c=0; c<COLS; c++) {
          let r = getNextRowForBoard(boardState, c);
          if(r === -1) continue;
          boardState[r][c] = 2;
          let evalScore = minimax(boardState, depth -1, false, alpha, beta);
          boardState[r][c] = 0;
          maxEval = Math.max(maxEval, evalScore);
          alpha = Math.max(alpha, evalScore);
          if(beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for(let c=0; c<COLS; c++) {
          let r = getNextRowForBoard(boardState, c);
          if(r === -1) continue;
          boardState[r][c] = 1;
          let evalScore = minimax(boardState, depth -1, true, alpha, beta);
          boardState[r][c] = 0;
          minEval = Math.min(minEval, evalScore);
          beta = Math.min(beta, evalScore);
          if(beta <= alpha) break;
        }
        return minEval;
      }
    }

    function isTerminalNode(boardState) {
      return checkBoardWin(boardState, 1) || checkBoardWin(boardState, 2) || checkBoardDraw(boardState);
    }

    function checkBoardWin(boardState, player) {
      // cherche 4 cons√©cutifs pour player
      for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
          if(boardState[r][c] === player) {
            if(checkDirection(boardState, r, c, 0, 1, player)) return true;
            if(checkDirection(boardState, r, c, 1, 0, player)) return true;
            if(checkDirection(boardState, r, c, 1, 1, player)) return true;
            if(checkDirection(boardState, r, c, 1, -1, player)) return true;
          }
        }
      }
      return false;
    }

    function checkDirection(boardState, row, col, dr, dc, player) {
      for(let i=0; i<4; i++) {
        let r = row + i*dr;
        let c = col + i*dc;
        if(r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
        if(boardState[r][c] !== player) return false;
      }
      return true;
    }

    function checkBoardDraw(boardState) {
      for(let c=0; c<COLS; c++) {
        if(boardState[0][c] === 0) return false;
      }
      return true;
    }

    function getNextRowForBoard(boardState, col) {
      for(let r=ROWS-1; r>=0; r--) {
        if(boardState[r][col] === 0) return r;
      }
      return -1;
    }

    function evaluateBoard(boardState) {
      if(checkBoardWin(boardState, 2)) return 1000;
      if(checkBoardWin(boardState, 1)) return -1000;
      return 0;
    }

    // Init & start
    initBoard();

  </script>
</body>
</html>

